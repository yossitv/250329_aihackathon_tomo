<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Âè≥Êâã„Éü„ÇÆ„Éº„Éá„É¢</title>
  <style>
    body { margin: 0; font-family: sans-serif; overflow: hidden; background: #111; }
    canvas { display: block; }
    #videoElement { display: none; }
    #errorMsg { color: red; position: absolute; top: 10px; left: 10px; background: #000a; padding: 10px; border-radius: 4px; z-index: 100; }
    
    /* „ÉÅ„É£„ÉÉ„ÉàUI„ÅÆ„Çπ„Çø„Ç§„É´ */
    #chatContainer {
      position: absolute;
      bottom: 70px;
      right: 20px;
      width: 350px;
      height: 400px;
      background: rgba(30, 30, 30, 0.8);
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      z-index: 10;
    }
    
    #chatHeader {
      padding: 10px;
      background: #333;
      color: white;
      font-weight: bold;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #minimize {
      cursor: pointer;
      user-select: none;
    }
    
    #chatMessages {
      flex-grow: 1;
      overflow-y: auto;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .message {
      max-width: 80%;
      padding: 8px 12px;
      border-radius: 15px;
      word-break: break-word;
    }
    
    .user-message {
      align-self: flex-end;
      background: #2b5278;
      color: white;
    }
    
    .bot-message {
      align-self: flex-start;
      background: #333;
      color: white;
    }
    
    #chatInputContainer {
      display: flex;
      padding: 10px;
      background: #222;
    }
    
    #chatInput {
      flex-grow: 1;
      border: none;
      padding: 8px 12px;
      border-radius: 20px;
      background: #444;
      color: white;
    }
    
    #chatInput:focus {
      outline: none;
    }
    
    #sendButton {
      background: #2b5278;
      color: white;
      border: none;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      margin-left: 8px;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    #sendButton:hover {
      background: #3c6ea5;
    }
    
    #speechText {
      color: #fff;
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: #222a;
      padding: 10px;
      border-radius: 4px;
      max-width: 300px;
    }

    #minimizedChat {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: #2b5278;
      color: white;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      display: none;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      z-index: 10;
    }
    
    /* Ë®≠ÂÆö„Éë„Éç„É´ */
    #configPanel {
      position: absolute;
      top: 10px;
      right: 20px;
      background: rgba(30, 30, 30, 0.9);
      padding: 15px;
      border-radius: 8px;
      z-index: 100;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }
    
    #configPanel h3 {
      margin-top: 0;
      color: white;
    }
    
    #apiKeyInput {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #333;
      color: white;
    }
    
    #saveApiKey {
      padding: 8px 12px;
      background: #2b5278;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    #saveApiKey:hover {
      background: #3c6ea5;
    }
    
    /* ÁèæÂú®„ÅÆ„Ç∏„Çß„Çπ„ÉÅ„É£„ÉºË°®Á§∫ */
    #gestureIndicator {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 8px 12px;
      background: rgba(30, 30, 30, 0.8);
      color: white;
      border-radius: 4px;
      font-size: 14px;
      z-index: 10;
    }
    
    /* „Éû„Ç§„ÇØ„Éú„Çø„É≥ */
    #micButton {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: #f44336;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      z-index: 10;
    }
    
    #micButton.listening {
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.7);
      }
      70% {
        box-shadow: 0 0 0 15px rgba(244, 67, 54, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(244, 67, 54, 0);
      }
    }
    
    #micIcon {
      width: 30px;
      height: 30px;
      fill: white;
    }
  </style>
</head>
<body>
  <video id="videoElement" autoplay playsinline></video>
  <div id="errorMsg"></div>
  <div id="gestureIndicator">„Ç∏„Çß„Çπ„ÉÅ„É£„Éº: ÈÄöÂ∏∏</div>
  <div id="speechText">Èü≥Â£∞Ë™çË≠ò‰∏≠...</div>
  
  <!-- „ÉÅ„É£„ÉÉ„ÉàUI -->
  <div id="chatContainer">
    <div id="chatHeader">
      <span>Âè≥Êâã„Éü„ÇÆ„Éº„Å®„ÉÅ„É£„ÉÉ„Éà</span>
      <span id="minimize">‚àí</span>
    </div>
    <div id="chatMessages"></div>
    <div id="chatInputContainer">
      <input type="text" id="chatInput" placeholder="„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂÖ•Âäõ..." />
      <button id="sendButton">‚Üë</button>
    </div>
  </div>
  
  <div id="minimizedChat">üí¨</div>
  
  <!-- „Éû„Ç§„ÇØ„Éú„Çø„É≥ -->
  <div id="micButton">
    <svg id="micIcon" viewBox="0 0 24 24">
      <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z" />
    </svg>
  </div>
  
  <!-- Ë®≠ÂÆö„Éë„Éç„É´ -->
  <div id="configPanel">
    <h3>Ë®≠ÂÆö</h3>
    <input type="text" id="apiKeyInput" placeholder="OpenAI API„Ç≠„Éº„ÇíÂÖ•Âäõ" />
    <button id="saveApiKey">‰øùÂ≠ò</button>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  
  <script type="module">
    // API„Ç≠„Éº„ÅÆÁÆ°ÁêÜ
    const apiKeyInput = document.getElementById('apiKeyInput');
    const saveApiKey = document.getElementById('saveApiKey');
    
    let apiKey = localStorage.getItem('openai_api_key') || '';
    apiKeyInput.value = apiKey;
    
    saveApiKey.addEventListener('click', () => {
      apiKey = apiKeyInput.value.trim();
      localStorage.setItem('openai_api_key', apiKey);
      alert('API„Ç≠„Éº„Åå‰øùÂ≠ò„Åï„Çå„Åæ„Åó„Åü');
      document.getElementById('configPanel').style.display = 'none';
    });

    //Èü≥Â£∞Âá∫Âäõ„ÅÆÈñ¢Êï∞
    function speakText(text) {
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'ja-JP'; // Êó•Êú¨Ë™û„ÅÆÂ†¥Âêà
      window.speechSynthesis.speak(utterance);
    }
    
    // Èü≥Â£∞Ë™çË≠ò„Å®ÂøúÁ≠îÂá¶ÁêÜ„ÅÆ„ÇØ„É©„Çπ
    class SpeechRecognizer {
      constructor(onTextCallback, onFinalCallback) {
        this.onTextCallback = onTextCallback;
        this.onFinalCallback = onFinalCallback;
        this.recognition = null;
        this.isListening = false;
        this.finalTranscript = '';
      }

      start() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          this.onTextCallback('Èü≥Â£∞Ë™çË≠ò„ÅØ„Åì„ÅÆ„Éñ„É©„Ç¶„Ç∂„Åß„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ');
          return;
        }
    
        this.recognition = new SpeechRecognition();
        this.recognition.lang = 'ja-JP';
        this.recognition.continuous = true;
        this.recognition.interimResults = true;
    
        this.recognition.onresult = (event) => {
          let interimTranscript = '';
          this.finalTranscript = '';
          
          for (let i = event.resultIndex; i < event.results.length; ++i) {
            const transcript = event.results[i][0].transcript;
            if (event.results[i].isFinal) {
              this.finalTranscript += transcript;
            } else {
              interimTranscript += transcript;
            }
          }
          
          // ‰∏≠ÈñìÁµêÊûú„Å®ÊúÄÁµÇÁµêÊûú„ÇíË°®Á§∫
          this.onTextCallback(this.finalTranscript || interimTranscript);
          
          // ÊúÄÁµÇÁµêÊûú„Åå„ÅÇ„Çå„Å∞„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„ÇíÂëº„Å≥Âá∫„Åô
          if (this.finalTranscript && this.onFinalCallback) {
            this.onFinalCallback(this.finalTranscript);
            this.finalTranscript = '';
          }
        };
    
        this.recognition.onerror = (event) => {
          console.warn('Speech recognition error:', event);
          this.isListening = false;
          document.getElementById('micButton').classList.remove('listening');
        };
        
        this.recognition.onend = () => {
          if (this.isListening) {
            this.recognition.start();
          } else {
            document.getElementById('micButton').classList.remove('listening');
          }
        };
    
        this.recognition.start();
        this.isListening = true;
        document.getElementById('micButton').classList.add('listening');
      }
    
      stop() {
        if (this.recognition) {
          this.isListening = false;
          this.recognition.stop();
        }
      }
      
      toggle() {
        if (this.isListening) {
          this.stop();
        } else {
          this.start();
        }
      }
    }
    
    // „Éè„É≥„Éâ„Ç∏„Çß„Çπ„ÉÅ„É£„ÉºÊ§úÂá∫„ÇØ„É©„Çπ
    class HandGestureDetector {
      constructor(onGestureDetected) {
        this.onGestureDetected = onGestureDetected;
        this.lastGesture = null;
        this.gestureStabilityCounter = 0;
        this.lastNotifiedGesture = null;
      }
      
      handleResults(landmarks) {
        const gesture = this.detectGesture(landmarks);
        
        // „Ç∏„Çß„Çπ„ÉÅ„É£„Éº„ÅÆÂÆâÂÆöÊÄß„ÇíÁ¢∫‰øù„Åô„Çã„Åü„ÇÅ„ÄÅÂêå„Åò„Ç∏„Çß„Çπ„ÉÅ„É£„Éº„ÅåÊï∞„Éï„É¨„Éº„É†Á∂ö„ÅÑ„Åü„ÇâÈÄöÁü•
        if (gesture) {
          if (gesture === this.lastGesture) {
            this.gestureStabilityCounter++;
            if (this.gestureStabilityCounter >= 5) { // 5„Éï„É¨„Éº„É†Âêå„Åò„Ç∏„Çß„Çπ„ÉÅ„É£„Éº„ÅåÁ∂ö„ÅÑ„Åü„Çâ
              if (this.onGestureDetected && gesture !== this.lastNotifiedGesture) {
                this.onGestureDetected(gesture);
                this.lastNotifiedGesture = gesture;
              }
            }
          } else {
            this.lastGesture = gesture;
            this.gestureStabilityCounter = 0;
          }
        }
      }
      
      detectGesture(landmarks) {
        // Êåá„ÅåÊõ≤„Åå„Å£„Å¶„ÅÑ„Çã„Åã„ÅÆÂà§ÂÆöÔºàYÂ∫ßÊ®ô„Çí‰ΩøÁî®Ôºâ
        const isFingerBent = (tip, pip) => landmarks[tip].y > landmarks[pip].y;
        
        // Ë¶™Êåá„ÅÆÂà§ÂÆöÔºàÂè≥Êâã„ÅÆÂ†¥ÂêàÔºâ
        const isThumbBent = () => landmarks[4].x > landmarks[2].x;
        
        // ÂêÑÊåá„ÅÆÁä∂ÊÖã„ÇíÁ¢∫Ë™ç
        const thumbBent = isThumbBent();
        const indexBent = isFingerBent(8, 6);
        const middleBent = isFingerBent(12, 10);
        const ringBent = isFingerBent(16, 14);
        const pinkyBent = isFingerBent(20, 18);
        
        // „Ç∏„Çß„Çπ„ÉÅ„É£„ÉºÂà§ÂÆö„É≠„Ç∏„ÉÉ„ÇØ
        if (!thumbBent && indexBent && middleBent && ringBent && pinkyBent) {
          return 'thumbs_up'; // üëç Ë¶™Êåá„Å†„ÅëÁ´ã„Å¶„Å¶„ÅÑ„Çã
        }
        
        if (thumbBent && !indexBent && middleBent && ringBent && pinkyBent) {
          return 'index'; // ‚òùÔ∏è ‰∫∫Â∑Æ„ÅóÊåá„Å†„ÅëÁ´ã„Å¶„Å¶„ÅÑ„Çã
        }
        
        if (thumbBent && indexBent && !middleBent && ringBent && pinkyBent) {
          return 'middle_finger'; // üñï ‰∏≠Êåá„Å†„ÅëÁ´ã„Å¶„Å¶„ÅÑ„Çã
        }
        
        if (thumbBent && indexBent && middleBent && ringBent && !pinkyBent) {
          return 'thumbs_down'; // üëé Â∞èÊåá„Å†„ÅëÁ´ã„Å¶„Å¶„ÅÑ„ÇãÔºàÊú¨ÂΩì„ÅØÈÅï„ÅÜ„Åë„Å©‰ª£Áî®Ôºâ
        }
        
        if (thumbBent && indexBent && middleBent && ringBent && pinkyBent) {
          return 'fist'; // ‚úä ÂÖ®„Å¶Êõ≤„Åí„Å¶„ÅÑ„Çã = Êã≥
        }
        
        if (!thumbBent && !indexBent && !middleBent && !ringBent && !pinkyBent) {
          return 'palm'; // ‚úã ÂÖ®„Å¶Èñã„ÅÑ„Å¶„ÅÑ„Çã = Êâã„ÅÆ„Å≤„Çâ
        }
        
        return null; // „Åù„ÅÆ‰ªñ„ÅÆ„Ç∏„Çß„Çπ„ÉÅ„É£„Éº
      }
    }
    
    // LLM (OpenAI API) Âëº„Å≥Âá∫„ÅóÈñ¢Êï∞
    async function getLLMResponse(userText, gesture = 'palm', apiKey = '') {
      const ENDPOINT = 'https://api.openai.com/v1/chat/completions';
      
      if (!apiKey) {
        throw new Error('API„Ç≠„Éº„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇË®≠ÂÆö„Éë„Éç„É´„Åã„ÇâAPI„Ç≠„Éº„ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
      }
      
      const tonePrompts = {
        fist: 'ÊÄí„Å£„ÅüÂè£Ë™ø„Åß„ÄÅÁü≠„ÅèËøîÁ≠î„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        palm: 'Êòé„Çã„ÅèÂâçÂêë„Åç„Å™ÊÑü„Åò„ÅßËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        thumbs_up: '„Åô„Åî„ÅèË§í„ÇÅ„ÅüÂè£Ë™ø„ÅßËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        index: 'ÊïôÂ∏´„ÅÆ„Çà„ÅÜ„Å™‰∏ÅÂØß„Å™Âè£Ë™ø„ÅßËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        middle_finger: '„Åã„Å™„ÇäÊîªÊíÉÁöÑ„ÅßÊØíËàå„Å™ÊÑü„Åò„ÅßËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        thumbs_down: 'Ë¶ã‰∏ã„Åó„Åü„Çà„ÅÜ„Å™ÊÑü„Åò„ÅßËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'
      };
      
      const systemPrompt = tonePrompts[gesture] || tonePrompts['palm'];
      
      try {
        const response = await fetch(ENDPOINT, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`,
          },
          body: JSON.stringify({
            model: 'gpt-3.5-turbo',
            messages: [
              { role: 'system', content: `„ÅÇ„Å™„Åü„ÅØ„ÄåÂè≥Êâã„Éü„ÇÆ„Éº„Äç„Å®„ÅÑ„ÅÜÂØÑÁîüÁîüÁâ©„ÅÆ„Ç≠„É£„É©„ÇØ„Çø„Éº„Åß„Åô„ÄÇ‰ºöË©±„ÅØÁ∞°ÊΩî„Å´„ÄÅ„ÇÑ„ÇÑ„Åµ„Åñ„Åë„ÅüÊÖãÂ∫¶„ÅßÂøúÁ≠î„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ${systemPrompt}` },
              { role: 'user', content: userText }
            ],
            max_tokens: 150
          })
        });
    
        if (!response.ok) {
          const errorData = await response.text();
          console.error('LLM fetch failed:', errorData);
          throw new Error(`APIÂëº„Å≥Âá∫„Åó„Ç®„É©„ÉºÔºà„Çπ„ÉÜ„Éº„Çø„Çπ: ${response.status}Ôºâ`);
        }
    
        const data = await response.json();
        return data.choices[0].message.content;
      } catch (error) {
        console.error('Error in getLLMResponse:', error);
        throw new Error('ÂøúÁ≠î„ÅÆÂèñÂæó‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ' + error.message);
      }
    }
    
    // DOMË¶ÅÁ¥†
    const videoElement = document.getElementById('videoElement');
    const errorMsg = document.getElementById('errorMsg');
    const speechText = document.getElementById('speechText');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const sendButton = document.getElementById('sendButton');
    const micButton = document.getElementById('micButton');
    const gestureIndicator = document.getElementById('gestureIndicator');
    const minimize = document.getElementById('minimize');
    const chatContainer = document.getElementById('chatContainer');
    const minimizedChat = document.getElementById('minimizedChat');
    
    // „ÉÅ„É£„ÉÉ„ÉàUI„ÅÆÁÆ°ÁêÜ
    minimize.addEventListener('click', () => {
      chatContainer.style.display = 'none';
      minimizedChat.style.display = 'flex';
    });
    
    minimizedChat.addEventListener('click', () => {
      chatContainer.style.display = 'flex';
      minimizedChat.style.display = 'none';
    });
    
    // „Éû„Ç§„ÇØ„Éú„Çø„É≥„ÅÆÂá¶ÁêÜ
    let speechRecognizer;
    micButton.addEventListener('click', () => {
      if (!speechRecognizer) {
        speechRecognizer = new SpeechRecognizer(
          (text) => {
            speechText.textContent = text || 'Èü≥Â£∞Ë™çË≠ò‰∏≠...';
          },
          (finalText) => {
            if (finalText.trim()) {
              addMessage(finalText, 'user');
              processUserInput(finalText);
            }
          }
        );
      }
      
      speechRecognizer.toggle();
    });
    
    // „ÉÜ„Ç≠„Çπ„ÉàÂÖ•Âäõ„ÅÆÂá¶ÁêÜ
    sendButton.addEventListener('click', sendMessage);
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });
    
    function sendMessage() {
      const message = chatInput.value.trim();
      if (message) {
        addMessage(message, 'user');
        processUserInput(message);
        chatInput.value = '';
      }
    }
    
    // „É°„ÉÉ„Çª„Éº„Ç∏„ÅÆËøΩÂä†
    function addMessage(text, sender) {
      const messageElement = document.createElement('div');
      messageElement.classList.add('message');
      messageElement.classList.add(sender + '-message');
      messageElement.textContent = text;
      chatMessages.appendChild(messageElement);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    // ÁèæÂú®„ÅÆ„Ç∏„Çß„Çπ„ÉÅ„É£„Éº
    let currentGesture = 'palm';
    
    // „É¶„Éº„Ç∂„ÉºÂÖ•Âäõ„ÅÆÂá¶ÁêÜ
    async function processUserInput(text) {
      try {
        // „ÄåËÄÉ„Åà‰∏≠...„Äç„ÅÆË°®Á§∫
        const thinkingMsg = document.createElement('div');
        thinkingMsg.classList.add('message', 'bot-message');
        thinkingMsg.textContent = 'ËÄÉ„Åà‰∏≠...';
        chatMessages.appendChild(thinkingMsg);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        const response = await getLLMResponse(text, currentGesture, apiKey);
        
        // „ÄåËÄÉ„Åà‰∏≠...„Äç„ÇíÂâäÈô§
        chatMessages.removeChild(thinkingMsg);
        
        // ÂøúÁ≠î„ÇíË°®Á§∫
        addMessage(response, 'bot');

        // Èü≥Â£∞Âá∫Âäõ„ÇíÂÆüË°å
        speakText(response);
      } catch (error) {
        console.error('Error processing input:', error);
        addMessage('„Ç®„É©„Éº: ' + error.message, 'bot');
      }
    }
    
    // Three.jsÈñ¢ÈÄ£„ÅÆË®≠ÂÆö
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const handGroup = new THREE.Group();
    scene.add(handGroup);

    // „Ç≠„É£„É©„ÇØ„Çø„Éº„ÅÆÁõÆÔºàÁôΩÁõÆÔºâ
    const eyeGroup = new THREE.Group();
    const eyeGeometry = new THREE.SphereGeometry(0.05, 32, 32);
    const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
    
    // Áû≥Â≠îÔºàÈªíÁõÆÔºâ
    const pupilGeometry = new THREE.SphereGeometry(0.025, 32, 32);
    const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
    pupil.position.z = 0.035;
    eye.add(pupil);
    eyeGroup.add(eye);
    
    // „Åæ„Å∂„Åü
    const eyelidGeometry = new THREE.SphereGeometry(0.055, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
    const eyelidMaterial = new THREE.MeshBasicMaterial({ 
      color: 0x333333, 
      side: THREE.DoubleSide 
    });
    const eyelid = new THREE.Mesh(eyelidGeometry, eyelidMaterial);
    eyelid.rotation.x = Math.PI;
    eyelid.position.z = 0.01;
    eyelid.visible = false;  // ÂàùÊúüÁä∂ÊÖã„Åß„ÅØÈùûË°®Á§∫
    eyeGroup.add(eyelid);

    // Âè£
    const mouthGroup = new THREE.Group();
    const mouthGeometry = new THREE.CircleGeometry(0.03, 32);
    const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0xff3333 });
    const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
    mouth.rotation.x = -Math.PI / 2;
    mouthGroup.add(mouth);

    scene.add(eyeGroup);
    scene.add(mouthGroup);
    camera.position.z = 1;

    // MediaPipe Hands
    const hands = new Hands({ locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7,
    });

    // Êâã„ÅÆ„Ç∏„Éß„Ç§„É≥„ÉàÔºàÈñ¢ÁØÄÔºâË°®Á§∫Áî®
    const joints = [];
    for (let i = 0; i < 21; i++) {
      const jointGeo = new THREE.SphereGeometry(0.01, 16, 16);
      const jointMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 });
      const joint = new THREE.Mesh(jointGeo, jointMat);
      handGroup.add(joint);
      joints.push(joint);
    }

    // Èü≥Â£∞„É¨„Éô„É´
    let audioLevel = 0;
    
    // „Ç∏„Çß„Çπ„ÉÅ„É£„ÉºÊ§úÂá∫„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ‰ΩúÊàê
    const gestureDetector = new HandGestureDetector((gesture) => {
      console.log('Detected gesture:', gesture);
      currentGesture = gesture;
      
      // „Ç∏„Çß„Çπ„ÉÅ„É£„ÉºË°®Á§∫„ÇíÊõ¥Êñ∞
      const gestureNames = {
        'fist': '‚úä ÊÄí„Çä',
        'palm': '‚úã ÈÄöÂ∏∏',
        'thumbs_up': 'üëç Ë§í„ÇÅ„Çã',
        'index': '‚òùÔ∏è ‰∏ÅÂØß',
        'middle_finger': 'üñï ÊØíËàå',
        'thumbs_down': 'üëé Ë¶ã‰∏ã„Åô'
      };
      
      gestureIndicator.textContent = '„Ç∏„Çß„Çπ„ÉÅ„É£„Éº: ' + (gestureNames[gesture] || '‰∏çÊòé');
      
      // „Ç∏„Çß„Çπ„ÉÅ„É£„Éº„Å´Âøú„Åò„Å¶ÁõÆ„ÅÆËâ≤„ÇíÂ§âÊõ¥
      switch(gesture) {
        case 'fist':
          eyeMaterial.color.set(0xff0000); // Ëµ§
          break;
        case 'palm':
          eyeMaterial.color.set(0xffffff); // ÁôΩ
          break;
        case 'thumbs_up':
          eyeMaterial.color.set(0x00ff00); // Á∑ë
          break;
        case 'index':
          eyeMaterial.color.set(0x00ffff); // Ê∞¥Ëâ≤
          break;
        case 'middle_finger':
          eyeMaterial.color.set(0xff00ff); // „Éû„Çº„É≥„Çø
          break;
        case 'thumbs_down':
          eyeMaterial.color.set(0x0000ff); // Èùí
          break;
      }
    });

    // MediaPipe Hands„ÅÆÁµêÊûú„ÇíÂá¶ÁêÜ
    hands.onResults(results => {
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        // Êâã„ÅÆ„Ç∏„Éß„Ç§„É≥„Éà„ÇíË°®Á§∫
        for (let i = 0; i < landmarks.length; i++) {
          const lm = landmarks[i];
          const x = (lm.x - 0.5) * 2;
          const y = -(lm.y - 0.5) * 2;
          const z = -lm.z;
          joints[i].position.set(x, y, z);
          joints[i].visible = true;
        }
        
        // Êåá„ÅÆÈñ¢ÁØÄ‰ΩçÁΩÆ„Åã„ÇâÁõÆ„Å®Âè£„ÅÆ‰ΩçÁΩÆ„ÇíË®àÁÆó
        const middleFinger = landmarks[12]; // ‰∏≠Êåá„ÅÆÂÖàÁ´Ø
        const palm = landmarks[0];          // Êâã„ÅÆ„Å≤„Çâ„ÅÆ‰∏≠ÂøÉ
        
        // ÁõÆ„Çí‰∏≠Êåá„ÅÆÂÖàÁ´Ø„Å´ÈÖçÁΩÆ
        eyeGroup.position.set(
          (middleFinger.x - 0.5) * 2, 
          -(middleFinger.y - 0.5) * 2, 
          -middleFinger.z
        );
        
        // Âè£„ÇíÊâã„ÅÆ„Å≤„Çâ„Å´ÈÖçÁΩÆ
        mouthGroup.position.set(
          (palm.x - 0.5) * 1.7, 
          -(palm.y - 0.5) * 0.6, 
          -palm.z
        );
        
        // „Ç∏„Çß„Çπ„ÉÅ„É£„Éº„ÇíÊ§úÂá∫
        gestureDetector.handleResults(landmarks);
      } else {
        // Êâã„ÅåÊ§úÂá∫„Åï„Çå„Å™„ÅÑÂ†¥Âêà„ÅØ„Ç∏„Éß„Ç§„É≥„Éà„ÇíÈùûË°®Á§∫„Å´
        for (let i = 0; i < joints.length; i++) {
          joints[i].visible = false;
        }
      }
    });

    // „Ç´„É°„É©ÈñãÂßã
    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        videoElement.srcObject = stream;

        // Èü≥Â£∞„É¨„Éô„É´„ÅÆÊ§úÂá∫
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioCtx.createMediaStreamSource(stream);
        const analyser = audioCtx.createAnalyser();
        source.connect(analyser);
        analyser.fftSize = 128;
        const dataArray = new Uint8Array(analyser.frequencyBinCount);

        const updateAudioLevel = () => {
          analyser.getByteFrequencyData(dataArray);
          const sum = dataArray.reduce((a, b) => a + b, 0);
          audioLevel = sum / dataArray.length / 128;
          requestAnimationFrame(updateAudioLevel);
        };
        updateAudioLevel();

        // „Ç´„É°„É©ÁîªÂÉè„ÅÆÂá¶ÁêÜ
        const cameraUtils = new Camera(videoElement, {
          onFrame: async () => {
            await hands.send({ image: videoElement });
          },
          width: 640,
          height: 480,
        });
        cameraUtils.start();
        
        // ÂàùÊúü„É°„ÉÉ„Çª„Éº„Ç∏
        setTimeout(() => {
          addMessage('„Åì„Çì„Å´„Å°„ÅØÔºÅÂè≥Êâã„Éü„ÇÆ„Éº„Åß„Åô„ÄÇ‰Ωï„ÅãË©±„Åó„Åã„Åë„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Éû„Ç§„ÇØ„Éú„Çø„É≥„ÇíÊäº„Åô„Åã„ÄÅ„ÉÜ„Ç≠„Çπ„Éà„ÅßÂÖ•Âäõ„Åß„Åç„Åæ„ÅôÔºÅ', 'bot');
        }, 1000);
      } catch (err) {
        console.error('Failed to acquire camera/audio feed:', err);
        errorMsg.textContent = '„Ç´„É°„É©„Åæ„Åü„ÅØ„Éû„Ç§„ÇØ„ÅÆ‰ΩøÁî®„ÅåË®±ÂèØ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇHTTPS„Åß„Ç¢„ÇØ„Çª„Çπ„Åó„Å¶„ÄÅË®±ÂèØ„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
      }
    }

    startCamera();

    // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„É´„Éº„Éó
    let blinkTimer = 0;
    
    function animate() {
      requestAnimationFrame(animate);
      
      // Âè£„ÅÆÈñãÈñâ„Çí„Ç™„Éº„Éá„Ç£„Ç™„É¨„Éô„É´„Å´Âêà„Çè„Åõ„Å¶Ë™øÊï¥
      const scale = Math.min(2.5, 0.5 + audioLevel * 3);
      mouth.scale.y = scale;
      
      // „É©„É≥„ÉÄ„É†„Å´Áû¨„Åç
      blinkTimer++;
      if (blinkTimer > 100) {
        if (Math.random() < 0.02) { // 2%„ÅÆÁ¢∫Áéá„ÅßÁû¨„Åç
          eyelid.visible = true;
          setTimeout(() => {
            eyelid.visible = false;
          }, 200);
          blinkTimer = 0;
        }
      }
      
      // Áû≥Â≠î„ÅÆÂãï„ÅçÔºà„É©„É≥„ÉÄ„É†„Å´Â∞ë„ÅóÊè∫„Çâ„ÅôÔºâ
      pupil.position.x = Math.sin(Date.now() * 0.001) * 0.01;
      pupil.position.y = Math.cos(Date.now() * 0.0013) * 0.01;
      
      renderer.render(scene, camera);
    }
    animate();
    
    // „Ç¶„Ç£„É≥„Éâ„Ç¶„Çµ„Ç§„Ç∫Â§âÊõ¥ÊôÇ„ÅÆÂá¶ÁêÜ
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>